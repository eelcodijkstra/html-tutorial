<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Tutorial 1</title>
    <!-- this stylesheet provides default styles for tutorials -->
    <link href="https://thimble.webmaker.org/learning_projects/tutorial/tutorial.css" rel="stylesheet">
    <!-- these scripts turn your make into a tutorial -->
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
    <script src="https://thimble.webmaker.org/learning_projects/tutorial/tutorial.js"></script>

    <script>
      jQuery(document).ready(function($){
        $('body').tutorial();
      });
    </script>

  </head>
  <body>
    <!--
      enclose each tutorial step in its own section tags
      you can include any sort of markup, including images
      you can also add more sections

      if you want to attach this tutorial to another make,
      first publish this make
      then tag the other make with prefix "tutorial-" followed by the url for this make
    -->

    <section>
      <h1>Programmeren in JavaScript - Les 2</h1>

     <p> Dit is de tweede les in Programmeren in Javascript.
       Naast deze tutorials is er een uitleg via XXX.
     </p>

            <p> Ga nu naar de volgende pagina. </p>
    </section>
    <section>
      <h1>Functies met parameters</h1>
      <p> We hebben gezien hoe je in een functie-definitie een aantal opdrachten
        kunt groeperen en een naam kunt geven.
      </p>
      <p>Nu gaan we een stap verder: we definiëren functies met parameters.
      </p>
      <p> We hebben steeds de functies <code>forward(n)</code> en <code>right(n)</code>
        gebruikt: door de parameters - het aantal stappen vooruit, of het aantal stappen
        draaien - zijn deze functies handiger dan een functie die
        een vast aantal stappen gebruikt.
      </p>
      <p>
      </p>

      <hr>
      <p><em>Opdrachten:</em></p>
      <ul>
        <li> P.M.
        </li>
        <li> idem
        </li>
      </ul>

    </section>

    <section>
      <h1>Voorbeeld: vierkant</h1>
      <p> Door een parameter voor de grootte in te voeren, kunnen we een algemene
        functie maken voor het tekenen van een vierkant:
      </p>
      <pre>
function square(size) {
  forward(size); right(90);
  forward(size); right(90);
  forward(size); right(90);
  forward(size); right(90);
}</pre>
      <p> We schrijven de parameter tussen de haakjes, na de naam van de functie.
      </p>

      <hr>
      <p><em>Opdrachten:</em></p>
      <ul>
        <li>Kopieer deze functie-definitie naar het JavaScript-venster, in het gedeelte voor
          user-defined functions.<br>
          Maak een test-aanroep voor deze functie gekoppeld aan een knop
          (bijv. via functie <code>testB</code>).
        </li>
      </ul>
    </section>

    <section>
      <h1>Functies met meerdere parameters</h1>
      <p>We hebben nu ook een turtle-opdracht met meerdere parameters:</p>
      <pre>
turnRight(rad, deg)
</pre>
      <p>Met deze opdracht kun je de turtle een bocht laten maken over <code>deg</code> graden.
        De straal van de bocht is rad posities (pixels). Een kortere straal betekent een
        scherpere bocht.
      </p>

      <p>Een negatief argument voor <code>deg</code> geeft een bocht naar links.
      </p>

      <p>Door de aanroep <code>turnRight(50, 360);</code> tekent de turtle een cirkel met
      een straal van 50.
      </p>

      <p>Deze opdracht is een voorbeeld van een functie met meerdere parameters. Bij de
        aanroep scheiden we de parameters door komma's.
      </p>
      <hr>
      <p><em>Opdrachten:</em></p>
      <ul>
        <li> Probeer de opdracht <code>turnRight</code> uit met verschillende waarden voor
          de parameters.
        </li>
        <li> Probeer deze opdracht uit via het console.
        </li>
        <li>Ga na dat het effect van <code>right(n);</code> gelijk is aan dat van
          <code>turnRight(0, n);</code> Waarom zouden we dan toch een aparte opdracht
          <code>right</code> willen hebben?
        </li>
      </ul>
    </section>

    <section>
      <h1>Functies met meerdere parameters</h1>
      <p> We kunnen ook functies definiëren met meerdere parameters.
        De namen van deze parameters scheiden we dan door komma's, bijvoorbeeld:
      </p>
<pre>
function rectangle(width, height) {
  ...
} </pre>
      <p>Zoals we eerder gezien hebben, geven we bij de aanroep de parameters weer
        in aan lijst gescheiden door haakjes:
      </p>
<pre>
rectangle(60, 40);
</pre>
      <hr>
      <p><em>Opdrachten:</em></p>
      <ul>
        <li> Definieer een functie <code>rectangle</code> zoals hierboven beschreven, voor
          het tekenen van een rechthoek. Maak een test voor deze functie gekoppeld aan
          een knop (bijv. via <code>function testC()</code>).
        </li>
        <li> Waarom gebruiken we voor de draaiing een vaste waarde (90 graden)?
        </li>
      </ul>

    </section>

   <section>
      <h1>Namen voor parameters</h1>
      <p>
        We zijn vrij in de keuze van de naam, binnen zekere grenzen: (i) het moet een geldige
        Javascript-naam (identifier) zijn; (ii) als we meerdere parameters gebruiken, moeten
        de namen hiervan verschillen.
        <br>
        Een regel die niet tot de Javascript-spelregels hoort, maar wel tot de regels van
        goed programmeer-gedrag: gebruik namen met een duidelijke betekenis.
      </p>
      <hr>
      <p><em>Opdrachten:</em></p>
      <ul>
        <li>PM
        </li>
        <li>PM
        </li>
      </ul>
    </section>

    <section>
      <h1>Voorbeeld: driehoek</h1>
      <p>Op eenzelfde manier als een vierkant, kunnen we ook een driehoek tekenen.
        (Later zullen we dit generaliseren tot regelmatige n-hoeken.)
      </p>
<pre>
function triangle(size) {
   forward(size); right(120);
   forward(size); right(120);
   forward(size); right(120);
}
</pre>
      <p>Als je deze functie uitvoert, krijg je niet het gebruikelijke huisje te zien.
        Hoe kan dat?
      </p>
      <hr>
      <p><em>Opdrachten:</em></p>
      <ul>
        <li>Kopieer deze functie naar het JavaScript-venster, en maak een test voor
          deze functie (gekoppeld aan één van de knoppen).
        </li>
        <li>Vraag: waarom hebben we de laatste opdracht <code>right(120);</code> toegevoegd?
          Ook zonder die opdracht wordt er toch een driehoek getekend?
        </li>
        <li>Voeg aan de testfunctie nog een extra rotatie toe, bijvoorbeeld
          <code>right(30);</code>
        </li>
      </ul>
    </section>

       <section>
      <h1>Voorbeeld: huisje</h1>
      <p>Als voorbeeld willen we een huisje tekenen. Dit kan op verschillende manieren.
        We proberen hier een huisje te tekenen op basis van een vierkant en een driehoek.
        Een eerste poging ziet er dan bijvoorbeeld als volgt uit:
      </p>
<pre>
function house(size) {
  triangle(size);
  square(size);
}
</pre>
      <hr>
      <p><em>Opdrachten:</em></p>
      <ul>
        <li>Kopieer deze functie-definitie naar het JavaScript-venster. Maak een test-aanroep
          met een van de functies die aan de knoppen gekoppeld zijn. <br>
          Pas de functie <code>house</code> zo aan dat je een huisje krijgt.
        </li>
        <li>Voeg aan de test voor het huisje nog een extra opdracht toe, zodat je
          bij herhaald aanroepen (drukken op de knop) een straatje krijgt.
        </li>
        <li>Maak de definitie van <code>house</code> zo dat het huisje getekend wordt
          'als een doorlopende lijn', zonder de pen van het papier te halen.
        </li>
        <li>Merk je aan de kant van het gebruik (de test) iets van deze verandering?
        </li>
      </ul>
    </section>

    <section>
      <h1>Voorbeeld: blad</h1>
      <p> We geven hier een voorbeeld van een functie om een blad te tekenen:
      </p>
      <pre>
function leaf(rad, deg) {
  right(-deg);
  turnRight(rad, 2 * deg);
  right(180 - 2 * deg);
  turnRight(rad, 2 * deg);
  right(180 - deg);
}
</pre>
      <p> ... </p>
      <hr>
      <p><em>Opdrachten:</em></p>
      <ol>
        <li>Kopieer deze functie naar het JavaScript-deel voor user-defined functions.</li>
        <li>Probeer deze functie uit met verschillende waarden voor de parameters.
        </li>
        <li>Gebruik een van de test-functies voor het tekenen van een blad,
          gevolgd door een draai, bijv. <code>right(30);</code> Teken een bloem.
        </li>
        <li>Wat is de rol van de eerste opdracht, <code>right(-deg);</code> ?
        </li>
        <li>Wat is de rol van de middelste opdracht, <code>right(180 - 2 * deg);</code> ?
        </li>
         <li>Wat is de rol van de laatste opdracht, <code>right(180 - deg);</code> ?
        </li>
      </ol>
    </section>

    <section>
      <h1>Opstap naar herhaling</h1>
      <p>We willen het hele Canvas vullen met vierkanten van dezelfde grootte.
        Dit doen we door een basisfiguur steeds te herhalen.
        Hoe ziet deze basisfiguur eruit? Hebben we aan één basisfiguur
        genoeg?
      </p>
      <p>De basisfiguur moet meer zijn dan alleen een vierkant. Immers, als we een vierkant
        tekenen, komen we weer op het beginpunt uit. Als we daar weer een vierkant tekenen,
        overlapt deze precies met de vorige: we komen niet verder.
      </p>
      <pre>
function squareStep(size) {
  square(size);
  forward(size);
}</pre>
      <p>We kunnen nu een rij vierkanten naast elkaar tekenen door deze functie te herhalen:
      </p>
      <pre>
squareStep(10);
squareStep(10);
squareStep(10);</pre>
      <hr>
      <p><em>Opdrachten:</em></p>
      <ul>
        <li>Maak een vergelijkbare functie <code>squareStep1(size)</code> om een
          kolom vierkanten te tekenen, dus onder elkaar.
        </li>
        <li>PM
        </li>
      </ul>
    </section>
    <section>
      <h1>title</h1>
       <hr>
      <p><em>Opdrachten:</em></p>
      <ul>
        <li>PM
        </li>
        <li>PM
        </li>
      </ul>
    </section>

    <section>
      <h1>Andere manieren (1) </h1>
      <p>Er zijn verschillende manieren om een vlak te vullen met vierkantjes.
        We hebben tot nu toe één manier gezien: van links naar rechts, en van
        boven naar beneden - zoals je leest.
      </p>
      <p>Maar je kunt het ook anders doen. Probeer zelf een (of meer) andere
        manieren te bedenken. <br>
        <em>Hint:</em> hoe maai je een gazon?
      </p>
       <hr>
      <p><em>Opdrachten:</em></p>
      <ul>
        <li>PM
        </li>
        <li>PM
        </li>
      </ul>
    </section>
    <section>
      <h1>Andere manieren (2)</h1>
      <p>Een andere manier is om aan het eind van een rij, de rij eronder in de
        andere richting te doorlopen (van rechts naar links).
      </p>
      <p>Nog een andere manier is om kolom voor kolom in te vullen, in plaats van rij
        voor rij.
      </p>
      <p>Nog weer een andere manier is om het vlak van buiten naar binnen in te vullen.
        Of, van binnen naar buiten, spiraalsgewijs.
      </p>
       <hr>
      <p><em>Opdrachten:</em></p>
      <ul>
        <li>PM
        </li>
        <li>PM
        </li>
      </ul>
    </section>
    <section>
      <h1>Andere manieren (3)</h1>
      <p> We hebben een functie <code>turnRight(size)</code> gedefinieerd om het tekenen
        van de vierkanten in een andere richting voor te zetten:
      </p>
      <pre>
function turnRight(size) {
  right(90);
  forward(size);
}
      </pre>
       <hr>
      <p><em>Opdrachten:</em></p>
      <ul>
        <li> Hoe kun je met de twee functies <code>squareStep</code> en <code>turnRight</code>
          een vierkante rand van vierkanten tekenen, bijv. van 4 x 4? (totaal 12 vierkanten).
        </li>
        <li>Hoe kun je met de twee functies <code>squareStep</code> en <code>turnRight</code>
          een vierkant van 4 x 4 vierkanten tekenen? (totaal 16 vierkanten).
        </li>
        <li>Definieer een functie <code>turnLeft(size)</code> om de richting naar links te
          veranderen. <em>Hint:</em> zorg ervoor dat <br>
          <code>turnRight(30); turnLeft(30);</code> <br>
          weer op precies dezelfde positie uitkomt.
        </li>
      </ul>
    </section>

  </body>
</html>
